// Code generated by embed. DO NOT EDIT.

package main

import (
	"bytes"
	"crypto/sha1"
	"encoding/base64"
	"github.com/inabyte/embed/embedded"
	"io"
	"strings"
	"testing"
)

func TestFileServer(t *testing.T) {
	if FileHandler() == nil {
		t.Errorf("Call to FileServer did no return a handler")
	}
}

func TestBytes(t *testing.T) {
	FS.Walk("/", func(path string, info embedded.FileInfo, err error) error {
		if !info.IsDir() {
			t.Run(path[1:], func(t *testing.T) {
				if tag := getTag(bytes.NewReader(info.Bytes())); tag != info.Tag() {
					t.Errorf("checksum {%s} for file %s doesn't match recorded {%s}", tag, path, info.Tag())
				}
			})
		}
		return nil
	})
}

func TestString(t *testing.T) {
	FS.Walk("/", func(path string, info embedded.FileInfo, err error) error {
		if !info.IsDir() {
			t.Run(path[1:], func(t *testing.T) {
				s := info.String()
				if tag := getTag(strings.NewReader(s)); tag != info.Tag() {
					t.Errorf("checksum {%s} for file %s doesn't match recorded {%s}", tag, path, info.Tag())
				}
			})
		}
		return nil
	})
}

func TestOpen(t *testing.T) {
	FS.Walk("/", func(path string, info embedded.FileInfo, err error) error {
		if !info.IsDir() {
			t.Run(path[1:], func(t *testing.T) {
				f, err := FS.Open(path)
				if err != nil {
					t.Errorf("Open file %s return error %v", path, err)
				} else {
					defer f.Close()
				}
				if tag := getTag(f); tag != info.Tag() {
					t.Errorf("checksum {%s} for file %s doesn't match recorded {%s}", tag, path, info.Tag())
				}
			})
		}
		return nil
	})
}

func getTag(r io.Reader) string {
	h := sha1.New()
	io.Copy(h, r)
	hash := h.Sum(nil)
	return base64.RawURLEncoding.EncodeToString(hash[:]) + "-gz"
}
